# 性能优化

## 代码分割

### 动态导入

- 使用动态导入懒加载组件。
- 按需加载功能模块。

```typescript
// ✅ 正确：动态导入
import { defineAsyncComponent } from 'vue'

const LazyComponent = defineAsyncComponent(() => import('./LazyComponent.vue'))
```

### 路由懒加载

```typescript
// ✅ 正确：路由懒加载
const routes = [
  {
    path: '/hello',
    component: () => import('./Hello/index.vue')
  },
  {
    path: '/read',
    component: () => import('./Read/index.vue')
  }
]
```

## 数据缓存

### 缓存策略

- 合理使用缓存减少重复请求。
- 静态数据长期缓存，动态数据短期缓存。

```typescript
// ✅ 正确：数据缓存
const cache = new Map<string, any>()

const getData = async (key: string) => {
  if (cache.has(key)) {
    return cache.get(key)
  }
  const data = await fetchData(key)
  cache.set(key, data)
  return data
}
```

### 使用 uTools dbStorage

```typescript
// ✅ 正确：使用 dbStorage 缓存
const getCachedData = (key: string) => {
  const cached = window.utools.dbStorage.getItem(key)
  if (cached) {
    return cached
  }
  const data = fetchData()
  window.utools.dbStorage.setItem(key, data)
  return data
}
```

## 资源优化

### 图片优化

- 优化图片和静态资源。
- 使用适当的图片格式和尺寸。
- 压缩静态资源。

```vue
<!-- ✅ 正确：图片优化 -->
<template>
  <img 
    src="image.jpg" 
    alt="描述"
    loading="lazy"
    decoding="async"
  />
</template>
```

### 静态资源

- 使用 CDN 加速静态资源加载。
- 压缩 CSS 和 JavaScript 文件。
- 使用字体图标代替图片图标。

## 渲染优化

### 使用 computed

- 避免不必要的重新渲染。
- 使用 `computed` 缓存计算结果。

```typescript
// ✅ 正确：使用 computed 缓存
const filteredItems = computed(() => 
  items.value.filter(item => item.status === 'active')
)

// ❌ 错误：每次渲染都计算
const filteredItems = () => 
  items.value.filter(item => item.status === 'active')
```

### 使用 v-memo

- 使用 `v-memo` 优化列表渲染。

```vue
<!-- ✅ 正确：使用 v-memo -->
<template>
  <div v-for="item in items" :key="item.id" v-memo="[item.id, item.status]">
    {{ item.name }}
  </div>
</template>
```

### 避免不必要的响应式

```typescript
// ✅ 正确：使用 shallowRef 避免深度响应式
import { shallowRef } from 'vue'

const largeData = shallowRef({ /* 大量数据 */ })

// ✅ 正确：使用 markRaw 标记非响应式
import { markRaw } from 'vue'

const chartInstance = markRaw(new Chart(...))
```

## 事件处理优化

### 防抖和节流

```typescript
// ✅ 正确：防抖
import { debounce } from 'lodash-es'

const handleSearch = debounce((keyword: string) => {
  // 搜索逻辑
}, 300)

// ✅ 正确：节流
import { throttle } from 'lodash-es'

const handleScroll = throttle(() => {
  // 滚动逻辑
}, 100)
```

### 事件委托

```vue
<!-- ✅ 正确：事件委托 -->
<template>
  <div @click="handleClick">
    <button data-action="save">保存</button>
    <button data-action="cancel">取消</button>
  </div>
</template>

<script setup lang="ts">
const handleClick = (e: MouseEvent) => {
  const target = e.target as HTMLElement
  const action = target.dataset.action
  if (action === 'save') {
    // 保存逻辑
  } else if (action === 'cancel') {
    // 取消逻辑
  }
}
</script>
```

## 内存管理

### 清理资源

```typescript
// ✅ 正确：清理资源
import { onUnmounted } from 'vue'

onMounted(() => {
  const timer = setInterval(() => {
    // 定时任务
  }, 1000)

  onUnmounted(() => {
    clearInterval(timer)
  })
})
```

### 避免内存泄漏

```typescript
// ✅ 正确：避免内存泄漏
import { onUnmounted } from 'vue'

const eventListeners: Array<() => void> = []

onMounted(() => {
  const handler = () => {
    // 事件处理
  }
  window.addEventListener('resize', handler)
  eventListeners.push(() => {
    window.removeEventListener('resize', handler)
  })
})

onUnmounted(() => {
  eventListeners.forEach(cleanup => cleanup())
})
```

## 性能监控

### 性能测量

```typescript
// ✅ 正确：性能测量
const measurePerformance = (name: string, fn: () => void) => {
  const start = performance.now()
  fn()
  const end = performance.now()
  console.log(`${name} 耗时: ${end - start}ms`)
}

measurePerformance('数据处理', () => {
  // 处理逻辑
})
```

### 性能分析

- 使用浏览器开发者工具进行性能分析。
- 使用 Performance API 测量性能。
- 使用 Lighthouse 进行性能评估。

## 最佳实践

1. **代码分割**：使用动态导入懒加载组件
2. **数据缓存**：合理使用缓存减少重复请求
3. **资源优化**：优化图片和静态资源
4. **渲染优化**：避免不必要的重新渲染
5. **内存管理**：及时清理资源，避免内存泄漏
6. **性能监控**：定期进行性能分析和优化
