# 数据管理

## 本地数据存储

- 优先使用 uTools 的 `dbStorage` API 进行数据持久化（`window.utools.dbStorage`）。
- 复杂数据结构可通过 `window.services` 封装文件读写操作。
- 禁止直接使用 `localStorage`，统一通过封装层访问。

## 缓存管理规范

- **必须使用**统一的缓存接口（可通过 `window.services` 封装或直接使用 `window.utools.dbStorage`）。
- **禁止直接使用** `localStorage` 或原生存储 API。
- **统一错误处理**和日志记录。
- 所有缓存键定义在 `src/constants/cache-keys.ts`（如需要），使用常量避免硬编码。

### 正确的缓存操作

```typescript
// ✅ 正确：使用 uTools dbStorage
window.utools.dbStorage.setItem('key', value)
const data = window.utools.dbStorage.getItem('key')

// ✅ 正确：通过 window.services 封装
const data = window.services.getCache('key')
window.services.setCache('key', value)
```

### 错误的缓存操作

```typescript
// ❌ 错误：直接使用 localStorage
const data = localStorage.getItem('key')
localStorage.setItem('key', value)
```

## 数据验证

- 写入前必须验证数据有效性。
- 使用 TypeScript 类型定义确保类型安全。
- 验证失败时返回明确的错误信息。

```typescript
// ✅ 正确：写入前验证
const validateData = (data: FeatureData): { valid: boolean; errors: string[] } => {
  const errors: string[] = []
  if (!data.name?.trim()) errors.push('名称不能为空')
  return { valid: errors.length === 0, errors }
}
```

## 数据操作模式

### 统一写入

- **计算 next** → **持久化** → **原子替换**

```typescript
// ✅ 正确：统一写入模式
const next = [...items.value, newItem]
const res = await repo.saveAll(next)
if (res.success) items.value = next
```

### 查询过滤

- 静态过滤：使用 `computed`
- 动态过滤：使用方法

```typescript
// ✅ 正确：使用 computed 缓存
const activeItems = computed(() => 
  items.value.filter(item => item.status === 'active')
)

// ✅ 正确：动态过滤
const searchItems = (keyword: string) => 
  items.value.filter(item => item.name.includes(keyword))
```

### 错误处理

- **Store**：记录日志 + 向上抛出
- **Composable**：捕获错误 + UI 反馈（Toast）

```typescript
// ✅ 正确：Store 中的错误处理
try {
  const res = await repo.saveAll(next)
  if (!res.success) throw new Error('保存失败')
  items.value = next
  logger.logRequestSuccess(reqId, 200, { id })
} catch (e) {
  logger.logRequestError(reqId, e)
  throw e
}

// ✅ 正确：Composable 中的错误处理
try {
  await itemStore.addItem(data)
  window.utools.showNotification('添加成功')
} catch (error) {
  window.utools.showNotification('添加失败：' + error.message)
}
```

## 性能优化

| 场景 | ✅ 推荐 | ❌ 避免 |
|-----|---|---|
| 批量操作 | `saveAll(next)` 一次持久化 | 循环调用 `save()` |
| 懒加载 | 判断已加载再获取 | 重复加载 |
| 派生数据 | `computed` 缓存 | 方法每次计算 |
| 缓存操作 | `window.utools.dbStorage` 统一接口 | 直接使用 `localStorage` |

## 常见反模式

| 反模式 | 错误示例 | ✅ 正确做法 |
|----|---|---------|
| 页面直连 Repo | `const items = await itemRepo.getAll()` | 通过 Store 或 Composable 调用 |
| Store 含 UI 逻辑 | `window.utools.showNotification()` 在 Store 中 | Store 记录日志，Composable 反馈用户 |
| Composable 访问缓存 | `window.utools.dbStorage.getItem()` 在 Composable | 通过 Store 或 Repo 访问 |
| 直接使用存储 API | `localStorage.getItem('key')` | 使用 `window.utools.dbStorage` 或封装接口 |
| 多次持久化 | 直接修改 + 单次 `save()` | 计算 next → 批量 `saveAll()` |
